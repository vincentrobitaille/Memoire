---
title: "R Notebook"
output:
  pdf_document: default
  html_notebook: default
---
```{r message=FALSE, warning=FALSE}
library(spdep)
library(Matrix)
library(dplyr)
library(tidyr)
library(spatialreg)
```

# Générer des données (modèle latent)

Les le processus de génération des données pour le modèle latent est simplement un modèle SAR dont les données sont ensuite censurées.

```{r}

source("simul data.R")

df_censure_latent <- gen_data_latent(n = 100,
                                     beta_reel = c(1, 1),
                                     lambda_reel = 0.6,
                                     sigma2_reel = 1,
                                     seed = 6390)

df_latent <- df_censure_latent$donnee

W_latent <- df_censure_latent$W |> 
  as.matrix()
W_latent <- W_latent |> 
  mat2listw()
```

#### Estimation d'un modèle SAR classique (approche fréquentiste)

```{r}
# On réestime le modèle de base selon sa bonne forme
fit1.1 <- lagsarlm(y_latent ~ X1, data = df_latent, listw = W_latent)
summary(fit1.1)

# On estime le modèle original, mais sur les données censurées
fit1.2 <- lagsarlm(y_obs ~ X1, data = df_latent, listw = W_latent)
summary(fit1.2)
```

#### Estimation d'un modèle SAR classique (approche bayésienne)

```{r eval=FALSE, include=FALSE}
###
# IGNORER
###

# source("MH_spatial_latent.R")
# 
# m <- c(beta0 = 0, beta1 = 0)
# k <- length(m)
# V <- 100000*diag(k)
# h_beta <- c(a = 1, b = 1)
# h_gamma <- c(a = 1, b = 1)
# W_latent_mat <- W_latent |> 
#   listw2mat()
# # Variance proposition beta
# tau <- c(0.001, 0.1)
# # Variance proposition sigma2
# phi <- 0.1
# c_lambda = 0.05
# N_samp <- 200000
# 
# fit1.1_bayes <- MH_spatial(y = df_latent$y_latent,
#                            X = as.matrix(df_latent[,c("X0", "X1")]),
#                            h_beta = h_beta,
#                            h_gamma = h_gamma,
#                            m = m,
#                            V = diag(k),
#                            W = W_latent_mat,
#                            N = N_samp,
#                            tau = tau,
#                            phi = phi,
#                            c_lambda = c_lambda,
#                            init_param = c(beta0 = 10, 
#                                           beta1 = 10, 
#                                           sigma2 = 0.1, 
#                                           lambda = 0.1))
```

```{r eval=FALSE, include=FALSE}
###
# IGNORER
###
# fit1.1_bayes$accept |> 
#   mean(na.rm = TRUE)
# fit1.1_bayes |> 
#   slice_tail(n = N_samp - 1000) |> 
#   pull(accept) |> 
#   mean(na.rm = TRUE)
# # fit1.1_bayes |> select(!c(rho, accept)) |> ts() |> plot()
# fit1.1_bayes$beta0 |> ts() |> plot()
# fit1.1_bayes$beta1 |> ts() |> plot()
# fit1.1_bayes$lambda |> ts() |> plot()
# fit1.1_bayes$sigma2 |> ts() |> plot()
# 
# fit1.1_bayes_acc <- fit1.1_bayes |> 
#   filter(accept == 1)
# 
# fit1.1_bayes_acc_burn <- fit1.1_bayes_acc |> 
#   slice_tail(n = nrow(fit1.1_bayes_acc) - 1000)
#   
# 
# fit1.1_bayes_acc |> ts() |> forecast::autoplot()
# 
# fit1.1_bayes_acc_burn$beta0 |> ts() |> plot()
# fit1.1_bayes_acc_burn$beta1 |> ts() |> plot()
# fit1.1_bayes_acc_burn$sigma2 |> ts() |> plot()
# fit1.1_bayes_acc_burn$lambda |> ts() |> plot()
# 
# fit1.1_bayes_acc_burn$beta0 |> ts() |> acf()
# fit1.1_bayes_acc_burn$beta1 |> ts() |> acf()
# fit1.1_bayes_acc_burn$sigma2 |> ts() |> acf()
# fit1.1_bayes_acc_burn$lambda |> ts() |> acf()
# 
# fit1.1_bayes_acc_burn$beta0 |> hist()
# fit1.1_bayes_acc_burn$lambda |> hist()
# 
# fit1.1_bayes_acc_burn |> colMeans()
# 
# fit1.1_bayes_acc_burn |> ts() |> forecast::autoplot()
# 
# fit1.1_bayes_acc |> select(beta0, beta1, sigma2, lambda) |> ts() |> plot()

```

### Estimation du modèle SAR avec Gibbs-MH - sans latence

Méthode basée sur celle présentée dans "Introduction to spatial econometrics" de LeSage. Pour l'instant, l'estimation est seulement pour le modèle SAR avec une variable $y$ non censurée.

Ajout d'un module pour la censure (modèle latent, estimation des variables latentes avec l'algo de Gibbs présenté par Geweke) à venir. Référence exacte à ajouter.

  - Essentiellement, on rajoute une étape qui est un échantillonneur de gibbs pour chaque $y$ latent estimé à partir des autres observations tel que $p(y_j|y_1,..., y_{j-1}, y_{j+1},...,y_n)$

```{r}
source("MH_Gibbs_latent.R")

fit1.1_gibbs <- MH_Gibbs_latent(
  y = df_latent$y_latent,
  X = as.matrix(df_latent[,c("X0", "X1")]),
  W = listw2mat(W_latent),
  c_beta = c(0, 0),
  c_lambda = 0.01,
  h_T = 1e+10,
  N = 100000,
  h_igamma = c(a = 0, b = 0),
  theta_0 = c(beta0 = 0, beta1 = 0, 
              sigma2 = 0.5, lambda = 0.3)
  )

fit1.1_gibbs$accept |> 
  mean(na.rm = TRUE)
```

#### Complet (accept et rejet)

```{r}
fit1.1_gibbs$beta0 |> ts() |> forecast::autoplot()
fit1.1_gibbs$beta1 |> ts() |> forecast::autoplot()
fit1.1_gibbs$sigma2 |> ts() |> forecast::autoplot()
fit1.1_gibbs$lambda |> ts() |> forecast::autoplot()

```


#### Complet (accept)


```{r}
fit1.1_gibbs |> 
  filter(accept == 1) |>
  pull(beta0) |> ts() |> forecast::autoplot()
fit1.1_gibbs |> 
  filter(accept == 1) |>
  pull(beta1) |> ts() |> forecast::autoplot()
fit1.1_gibbs |> 
  filter(accept == 1) |>
  pull(sigma2) |> ts() |> forecast::autoplot()
fit1.1_gibbs |> 
  filter(accept == 1) |>
  pull(lambda) |> ts() |> forecast::autoplot()
```


#### ACF accept


```{r}
fit1.1_gibbs |> 
  filter(accept == 1) |>
  pull(beta0) |> ts() |> acf()
fit1.1_gibbs |> 
  filter(accept == 1) |>
  pull(beta1) |> ts() |> acf()
fit1.1_gibbs |> 
  filter(accept == 1) |>
  pull(sigma2) |> ts() |> acf()
fit1.1_gibbs |> 
  filter(accept == 1) |>
  pull(lambda) |> ts() |> acf()
```

### Estimation du modèle SAR avec Gibbs-MH - avec latence

```{r}
source("MH_Gibbs_latent.R")

fit1.2_gibbs <- MH_Gibbs_latent(
  y = df_latent$y_obs,
  X = as.matrix(df_latent[,c("X0", "X1")]),
  W = listw2mat(W_latent),
  c_beta = c(0, 0),
  c_lambda = 1,
  h_T = 1e+10,
  N = 5000000,
  h_igamma = c(a = 0, b = 0),
  theta_0 = c(beta0 = 0, beta1 = 0, 
              sigma2 = 0.5, lambda = 0.3),
  censure = 0,
  m_step = 1
  )
```

```{r}
fit1.2_gibbs$accept |> 
  mean(na.rm = TRUE)

fit1.2_acc <- fit1.2_gibbs |> 
  filter(accept == 1)

fit1.2_acc$beta0 |> hist()
fit1.2_acc$beta1 |> hist()
fit1.2_acc$sigma2 |> hist()
fit1.2_acc$lambda |> hist()
fit1.2_acc$y3 |> hist()
fit1.2_acc$y9 |> hist()
fit1.2_acc$y12 |> hist()

fit1.2_acc[,] |> colMeans()

fit1.2_acc$beta0 |> ts() |> forecast::autoplot()
fit1.2_acc$beta1 |> ts() |> forecast::autoplot()
fit1.2_acc$sigma2 |> ts() |> forecast::autoplot()
fit1.2_acc$lambda |> ts() |> forecast::autoplot()

fit1.2_acc$beta0 |> ts() |> acf()
fit1.2_acc$beta1 |> ts() |> acf()
fit1.2_acc$sigma2 |> ts() |> acf()
fit1.2_acc$lambda |> ts() |> acf()
```

