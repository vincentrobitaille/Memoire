---
title: "R Notebook"
output: html_notebook
---
```{r}
library(spdep)
library(Matrix)
library(dplyr)
library(tidyr)
library(spatialreg)
```

# Générer des données (modèle latent)

Les le processus de génération des données pour le modèle latent est simplement un modèle SAR dont les données sont ensuite censurées.

```{r}

source("simul data.R")

df_censure_latent <- gen_data_latent(n = 100,
                                     beta_reel = c(1, 1),
                                     lambda_reel = 0.6,
                                     sigma2_reel = 1,
                                     seed = 6390)

df_latent <- df_censure_latent$donnee

W_latent <- df_censure_latent$W |> as.matrix()
W_latent <- W_latent |> mat2listw()
```

#### Estimation d'un modèle SAR classique (approche fréquentiste)

```{r}
# On réestime le modèle de base selon sa bonne forme
fit1.1 <- lagsarlm(y_latent ~ X1, data = df_latent, listw = W_latent)
summary(fit1.1)

# On estime le modèle original, mais sur les données censurées
fit1.2 <- lagsarlm(y_obs ~ X1, data = df_latent, listw = W_latent)
summary(fit1.2)
```

#### Estimation d'un modèle SAR classique (approche bayésienne)

```{r}
source("estimation_latent.R")

m <- c(beta0 = 0, beta1 = 0)
k <- length(m)
V <- diag(k)
h_beta <- c(a = 1, b = 1)
h_gamma <- c(a = 1, b = 1)
W_latent_mat <- W_latent |> 
  listw2mat()
# Variance proposition beta
tau <- 0.01*diag(k)
# Variance proposition sigma2
phi <- 0.01
c_lambda = 0.01
N_samp <- 100000

fit1.1_bayes <- MH_spatial(y = df_latent$y_latent,
                           X = as.matrix(df_latent[,c("X0", "X1")]),
                           h_beta = h_beta,
                           h_gamma = h_gamma,
                           m = m,
                           V = diag(k),
                           W = W_latent_mat,
                           N = N_samp,
                           tau = tau,
                           phi = phi,
                           c_lambda = c_lambda,
                           init_param = c(beta0 = 0.1, 
                                          beta1 = 0.1, 
                                          sigma2 = 1, 
                                          lambda = 0.1))

fit1.1_bayes$accept |> mean(na.rm = TRUE)
# fit1.1_bayes |> select(!c(rho, accept)) |> ts() |> plot()
fit1.1_bayes$beta0 |> ts() |> plot()
fit1.1_bayes$beta1 |> ts() |> plot()
fit1.1_bayes$lambda |> ts() |> plot()
fit1.1_bayes$sigma2 |> ts() |> plot()

fit1.1_bayes_acc <- fit1.1_bayes |> 
  filter(accept == 1)

fit1.1_bayes_acc_burn <- fit1.1_bayes_acc |> 
  slice_tail(n = N_samp - 500)
  

fit1.1_bayes_acc |> ts() |> forecast::autoplot()

fit1.1_bayes_acc_burn$beta0 |> ts() |> acf()
fit1.1_bayes_acc_burn$beta1 |> ts() |> acf()
fit1.1_bayes_acc_burn$sigma2 |> ts() |> acf()
fit1.1_bayes_acc_burn$lambda |> ts() |> acf()

fit1.1_bayes_acc_burn$beta0 |> hist()
fit1.1_bayes_acc_burn$lambda |> hist()

fit1.1_bayes_acc_burn |> colMeans()

fit1.1_bayes_acc_burn |> ts() |> forecast::autoplot()

fit1.1_bayes_acc |> select(beta0, beta1, sigma2, lambda) |> ts() |> plot()

```

